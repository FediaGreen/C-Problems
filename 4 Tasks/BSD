#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <iostream>
#include <string>
#include <vector>

class BSD { // not done yet
 public:
  BSD(const std::vector<int>& v, bool IsPositive, size_t precision) :
      digits_(v), IsPositive_(IsPositive), precision_(precision) {}

  BSD() : BSD(0) {}

  BSD(int num) {
    Set(num);
  }

  BSD(int num, bool IsPositive, size_t precision) :
    digits_({num}), IsPositive_(IsPositive), precision_(precision) {}
  

  BSD(const BSD& other) : 
    digits_(other.digits_), 
    IsPositive_(other.IsPositive_), 
    precision_(other.precision_) {}

  // BSD(double num) { // problems with precision
  //   SetWholePart(num);
  //   SetFractionalPart(num);
  // }

  BSD Division(int num, size_t precision) { // example: 8643,23423 (BSD) / 123 = 70,270197...
    int cnt_num = 0;
    int divide = 0;
    bool IsPositive = true;
    std::vector <int> ans;
    if (num < 0) {
      IsPositive = false;
      num *= -1;
    }
    int term = 0;
    size_t count_after_point = 0;
    for (size_t i = 0; count_after_point <= precision; ++i) {
      if (i >= digits_.size()) {
        term = 0;
      } else {
        term = digits_[i];
      }
      cnt_num *= 10;
      cnt_num += term;
      divide = cnt_num / num;
      cnt_num -= divide * num;
      ans.push_back(divide);
      if (i >= digits_.size() - precision_) { 
        ++count_after_point;
        if (count_after_point == precision) {
          break;
        }
      }
    }
    return BSD(ans, IsPositive, precision);
  }

  std::string GetView() {
    std::string view = "";
    if (!IsPositive_) {
      view += "-";
    }
    for (size_t i = 0; i < digits_.size(); ++i) {
      if (i == digits_.size() - precision_) {
        view += ",";
      }
      view += static_cast<char>(digits_[i] + 48);
    }
    return view;
  }

  BSD& operator=(const BSD& other) {
    digits_ = other.digits_;
    IsPositive_ = other.IsPositive_;
    precision_ = other.precision_;
    return *this;
  }

  BSD operator+(const BSD& other) {
    int this_idx = 0;
    int other_idx = 0;
    if (other.precision_ < precision_) {
      other_idx = int(other.digits_.size() - 1);
      this_idx = int(digits_.size() - 1 + other.precision_- precision_);
    } else {
      this_idx = int(digits_.size() - 1);
      other_idx = int(other.digits_.size() - 1 + precision_ - other.precision_);
    }
    std::vector<int> ans;
    int this_term = 0;
    int other_term = 0;
    int token = 0;
    int digit_ans = 0;
    if (other.digits_[size_t(other_idx)] + digits_[size_t(this_idx)] >= 10) {
      token = 1;
    }
    --this_idx;
    --other_idx;
    for (size_t i = 0; i < std::max(digits_.size(), other.digits_.size()); ++i) {
      if (this_idx < 0) {
        this_term = 0;
      } else {
        this_term = digits_[size_t(this_idx)];
      }
      if (other_idx < 0) {
        other_term = 0;
      } else {
        other_term = other.digits_[size_t(other_idx)];
      }
      digit_ans = this_term + other_term + token;
      ans.push_back(digit_ans % 10);
      token = 0;
      if (digit_ans >= 10) {
        token = 1;
      }
      --this_idx;
      --other_idx;
    }
    size_t idx = ans.size() - 1;
    while(ans[idx] == 0) {
      ans.pop_back();
      if (idx == 0) {
        break;
      } else {
        --idx;
      }
    }
    std::reverse(ans.begin(), ans.end());
    return BSD(ans, true, std::min(precision_, other.precision_) - 1);
  }

 private:
  bool Correct() { return digits_.size() <= size_t(10 + precision_); }
  void SetPositive(double num) {
    if (num < 0) {
      IsPositive_ = false;
      num *= -1;
    }
    IsPositive_ = true;
  }
  void SetFractionalPart(double num) {
    SetPositive(num);
    double n = num - std::floor(num);
    int digit = 0;
    size_t precision = 0;
    while (n > 0) {
      ++precision;
      n *= 10;
      digit = int(std::floor(n));
      digits_.push_back(digit);
      n -= digit;
    }
    precision_ = precision;
    Correct();
  }

  void Set(int num) {
    int n = static_cast<int>(num);
    precision_ = 0;
    SetPositive(n);
    int digit = 0; 
    digits_.clear();
    while (n >= 1) {
      digit = n % 10;
      digits_.push_back(digit);
      n /= 10;
    }
    std::reverse(digits_.begin(), digits_.end());
    assert(Correct() == true);
  }

  std::vector<int> digits_; // all digits
  bool IsPositive_; // The number is positive or negative 
  size_t precision_; // number of digits after comma-point
};

int main() {
  std::vector<int> num(201, 0);
  std::vector<int> num1(301, 0);
  num[0] = 1;
  num1[0] = 1;
  BSD e_num(num, true, 200);
  BSD curr_bsd(num1, true, 300);
  for (size_t i = 1; i <= 100; ++i) {
    curr_bsd = curr_bsd.Division(int(i), 300);
    e_num = e_num + curr_bsd;
  }
  std::cout << e_num.GetView();
  return 0;
}
